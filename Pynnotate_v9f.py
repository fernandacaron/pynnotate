## NOVA
# ======= ALIAS MAPS POR ORGANISMO/ORGANELA =======
alias_map_animal = {
    "12S": ["12 S RIBOSOMAL RNA", "12S", "12S RIBOSOMAL RNA", "12S RIBOSORMAL RNA", "12S RRN", "12S RRNA", "12S SMALL SUBUNIT RIBOSOMAL RNA", "12S-RRNA", "12SRRN", "12SRRNA", "12S_RIBOSOMAL_RNA", "12S_RRN", "MT-RNR1", "MTRNR1", "RNS", "RRN12", "RRNA-12S", "RRNAS", "RRNS", "S RRNA", "S-RRNA", "SMALL RIBOSOMAL RNA SUBUNIT RNA", "SMALL SUBUNIT RIBOSOMAL RNA", "SMALL SUBUNIT RIBOSORMAL RNA", "SMALL SUBUNIT RRNA", "SSU", "SSU RRNA", "12S ribosoma RNA"],
    "16S": ["16 S RIBOSOMAL RNA", "16RRN", "16S", "16S RIBOSOMAL RNA", "16S RRN", "16S RRNA", "16S LARGE SUBUNIT RIBOSOMAL RNA", "16S-RRNA", "16SRRN", "16SRRNA", "16S_RIBOSOMAL_RNA", "16S_RRN", "L RRNA", "L-RNA", "L-RRNA", "LARGE RIBOSOMAL RNA SUBUNIT RNA", "LARGE SUBUNIT RIBOSOMAL RNA", "LSU", "LSU RRNA", "MT-RNR2", "MTRNR2", "RNL", "RRL", "RRN16", "RRNAL", "RRNL", "16S ribosomalRNA", "16S bibosomal RNA"],
    "COI": ["CO I", "CO-I", "CO1", "COI", "COX I", "COX-I", "COX1", "COXI", "CYTOCHROME C OXIDASE SUBUNIT 1", "CYTOCHROME C OXIDASE SUBUNIT I", "CYTOCHROME C OXIDASE SUBUNIT1", "CYTOCHROME OXIDASE C SUBUNIT 1", "CYTOCHROME OXIDASE I", "CYTOCHROME OXIDASE SUBUNIT 1", "CYTOCHROME OXIDASE SUBUNIT I", "CYTOCHROME OXIDASE SUBUNIT1", "MT-CO1"],
    "COII": ["CO II", "CO2", "COII", "COX II", "COX-II", "COX2", "COXII", "CYTOCHROME C OXIDASE SUBUNIT 2", "CYTOCHROME C OXIDASE SUBUNIT II", "CYTOCHROME C OXIDASE SUBUNIT2", "CYTOCHROME OXIDASE II", "CYTOCHROME OXIDASE SUBUNIT 2", "CYTOCHROME OXIDASE SUBUNIT II", "CYTOCHROME OXIDASE SUBUNIT2", "MT-CO2"],
    "COIII": ["CO III", "CO3", "CO3 SUBUNIT 3", "COIII", "COX III", "COX-III", "COX3", "COXIII", "CYTOCHROME C OXIDASE SUBUNIT 3", "CYTOCHROME C OXIDASE SUBUNIT III", "CYTOCHROME C OXIDASE SUBUNIT3", "CYTOCHROME OXIDASE C SUBUNIT 3", "CYTOCHROME OXIDASE III", "CYTOCHROME OXIDASE SUBUNIT 3", "CYTOCHROME OXIDASE SUBUNIT III", "CYTOCHROME OXIDASE SUBUNIT3", "MT-CO3"],
    "CYTB": ["CB", "COB", "CTYB", "CYB", "CYT B", "CYT-B", "CYTB", "CYTOCHOROME B", "CYTOCHROME", "CYTOCHROME B", "CYT_B", "MT-CYB", "MT-CYTB"],
    "ND1": ["MT-ND1", "MTND1", "NAD1", "NADH DEHYDROGENASE 1", "NADH DEHYDROGENASE SUBUNIT 1", "NADH DEHYDROGENASE SUBUNIT I", "NADH DEHYDROGENASE SUBUNIT1", "NADH SUBUNIT 1", "NADH-1", "NADH1", "ND1"],
    "ND2": ["MT-ND2", "NAD2", "NADH DEHYDROGENASE SUBUNIT 2", "NADH DEHYDROGENASE SUBUNIT II", "NADH DEHYDROGENASE SUBUNIT2", "NADH SUBUNIT 2", "NADH2", "ND2"],
    "ND3": ["MT-ND3", "NAD3", "NADH DEHYDROGENASE SUBUNIT 3", "NADH DEHYDROGENASE SUBUNIT III", "NADH DEHYDROGENASE SUBUNIT3", "NADH SUBUNIT 3", "NADH3", "ND3", "ND3_1"],
    "ND4": ["4", "MT-ND4", "NAD4", "NADH DEHYDROGENASE SUBUNIT 4", "NADH DEHYDROGENASE SUBUNIT IV", "NADH DEHYDROGENASE SUBUNIT4", "NADH SUBUNIT 4", "NADH4", "ND4"],
    "ND4L": ["MT-ND4L", "NAD4L", "NADH DEHYDROGENASE SUBUNIT 4 L", "NADH DEHYDROGENASE SUBUNIT 4L", "NADH DEHYDROGENASE SUBUNIT IV L", "NADH DEHYDROGENASE SUBUNIT4L", "NADH SUBUNIT 4L", "NADH4L", "ND4L"],
    "ND5": ["MT-ND5", "NAD5", "NADH DEHYDROGENASE SUBUNIT 5", "NADH DEHYDROGENASE SUBUNIT V", "NADH DEHYDROGENASE SUBUNIT5", "NADH SUBUNIT 5", "NADH5", "ND5"],
    "ND6": ["MT-ND6", "NAD6", "NADH DEHYDROGENASE SUBUNIT 6", "NADH DEHYDROGENASE SUBUNIT VI", "NADH DEHYDROGENASE SUBUNIT6", "NADH SUBUNIT 6", "NADH6", "ND6"],
    "ATP6": ["APT6", "AT6", "ATP SYNTHASE 6", "ATP SYNTHASE F0 SUBUNIT 6", "ATP SYNTHASE SUBUNIT 6", "ATP SYTHASE SUBUNIT 6", "ATP6", "ATPASE 6", "ATPASE SUBUNIT 6", "ATPASE6", "F0-ATP SYNTHASE SUBUNIT6", "MT-ATP6", "MTATP6"],
    "ATP8": ["APT8", "AT8", "ATP SYNTHASE 8", "ATP SYNTHASE F0 SUBUNIT 8", "ATP SYNTHASE SUBUNIT 8", "ATP SYTHASE SUBUNIT 8", "ATP8", "ATPASE 8", "ATPASE SUBUNIT 8", "ATPASE8", "F0-ATP SYNTHASE SUBUNIT8", "MT-ATP8", "MTATP8"],
    "tRNA-Ala": ["TRNA", "TRNA ALA", "TRNA TGC", "TRNA(UGC)", "TRNA-ALA", "TRNA-UGC", "TRNA_ALA", "TRNA(TGC)", "TRNA-TGC"],
    "tRNA-Arg": ["TRNA ARG", "TRNA-ARG", "TRNA_ARG", "TRNR", "TRNR TCG", "TRNR(UCG)", "TRNR-UCG", "TRNA(TCG)", "TRNR(TCG)", "TRNR-TCG"],
    "tRNA-Asn": ["TRNA ASN", "TRNA-ASN", "TRNA_ASN", "TRNA-ASX", "TRNN", "TRNN GTT", "TRNN(GUU)", "TRNN-GUU", "TRNN(GTT)", "TRNN-GTT"],
    "tRNA-Asp": ["TRNA ASP", "TRNA-ASP", "TRNA_ASP", "TRND", "TRND GTC", "TRND(GUC)", "TRND-GUC", "TRND(GAC)", "TRND(GTC)", "TRND-GTC"],
    "tRNA-Cys": ["TRNA CYS", "TRNA-CYS", "TRNA_CYS", "TRNC", "TRNC GCA", "TRNC(GCA)", "TRNC-GCA", "TRNA(GCA)"],
    "tRNA-Gln": ["TRNA GLN", "TRNA-GLN", "TRNA_GLN", "TRNQ", "TRNQ TTG", "TRNQ(UUG)", "TRNQ-UUG", "TRNQ(TTG)", "TRNQ-TTG"],
    "tRNA-Glu": ["TRNA-GLU", "TRNA_GLU", "TRNE", "TRNE TTCTRNA GLU", "TRNE(UUC)", "TRNE-UUC", "TRNE(TTC)", "TRNE-TTC"],
    "tRNA-Gly": ["TRNA-GLY", "TRNA_GLY", "TRNG", "TRNG TCCTRNA GLY", "TRNG(UCC)", "TRNG-UCC", "TRNG(TCC)", "TRNG-TCC"],
    "tRNA-His": ["TRNA HIS", "TRNA-HIS", "TRNA_HIS", "TRNH", "TRNH GTG", "TRNH(GUG)", "TRNH-GUG", "TRNH(GTG)", "TRNH-GTG"],
    "tRNA-Ile": ["TRNA ILE", "TRNA-ILE", "TRNA_ILE", "TRNI", "TRNI GAT", "TRNI(GAU)", "TRNI-GAU", "TRNI(GAT)", "TRNI-GAT"],
    "tRNA-Leu": ["TRNA-LEU", "TRNA_LEU", "TRNL", "TRNA LEU(CUN)", "TRNA-LEU (CUN)", "TRNA-LEU(CUN)", "TRNL (CUN)", "TRNL(CUN)", "TRNL TAG", "TRNL(UAG)", "TRNL-UAG", "TRNL-TAG", "TRNL1", "TRNL1(TAG)", "TRNL(TAG)", "TRNA LEU(UUR)", "TRNA-LEU (UUR)", "TRNA-LEU(UUR)", "TRNL (UUR)", "TRNL(UUR)", "TRNL2", "TRNL2(TAA)", "TRNL2(TTA)"],
    "tRNA-Lys": ["TRNA-LYS", "TRNA_LYS", "TRNK", "TRNK TTTTRNA LYS", "TRNK(UUU)", "TRNK-UUU", "TRNK(TTT)", "TRNK-TTT"],
    "tRNA-Met": ["TRNA MET", "TRNA-MET", "TRNA_MET", "TRNM", "TRNM CAT", "TRNM(CAU)", "TRNM-CAU", "TRNM(CAT)", "TRNM-CAT", "TRNM_1(CAT)"],
    "tRNA-Phe": ["TRNA-PHE", "TRNA_PHE", "TRNF GAA", "TRNF(GAA)", "TRNF-GAA"],
    "tRNA-Pro": ["PROLINE TRNA", "TRNA PRO", "TRNA-PRO", "TRNA_PRO", "TRNP TGG", "TRNP(UGG)", "TRNP-UGG", "TRNP(TGG)", "TRNP-TGG"],
    "tRNA-Ser": ["TRNA SER (AGY)", "TRNA SER(UCN)", "TRNA-SER", "TRNA-SER (UCN)", "TRNA-SER(AGY)", "TRNA-SER(UCN)", "TRNA_SER", "TRNA_SER (AGY)", "TRNS", "TRNS GCT", "TRNS(GCU)", "TRNS(UGA)", "TRNS-UGA", "trnS1(gct)"],
    "tRNA-Thr": ["THREONINE TRNA", "TRNA THR", "TRNA-THR", "TRNA_THR", "TRNT TGT", "TRNT(UGU)", "TRNT-UGU", "TRNT(TGT)"],
    "tRNA-Trp": ["TRNA TRP", "TRNA-TRP", "TRNA_TRP", "TRNW", "TRNW TCA", "TRNW(UCA)", "TRNW-UCA", "TRNW(TCA)", "TRNW(TGA)", "TRNW-TCA"],
    "tRNA-Tyr": ["TRNA TYR", "TRNA-TYR", "TRNA_TYR", "TRNY", "TRNY GTA", "TRNY(GUA)", "TRNY-GUA", "TRNY(GTA)", "TRNY(TAC)", "TRNY-GTA"],
    "tRNA-Val": ["TRNA-VAL", "TRNA_VAL", "TRNV", "TRNV TAC", "TRNV(UAC)", "TRNV-UAC", "TRNV(TAC)", "TRNV-TAC"],
  
      # Ribossomais nucleares e ITS
    "18S": ["18S", "18S RRNA", "18S RIBOSOMAL RNA", "SMALL SUBUNIT RRNA"],
    "28S": ["28S", "28S RRNA", "28S RIBOSOMAL RNA", "LARGE SUBUNIT RRNA"],
    "ITS1": ["ITS1", "INTERNAL TRANSCRIBED SPACER 1"],
    "ITS2": ["ITS2", "INTERNAL TRANSCRIBED SPACER 2"],

    # Nucleares clássicos
    "RAG1": ["RAG1", "RECOMBINATION ACTIVATING GENE 1"],
    "RAG2": ["RAG2", "RECOMBINATION ACTIVATING GENE 2"],
    "BDNF": ["BDNF", "BRAIN-DERIVED NEUROTROPHIC FACTOR"],
    "CMOS": ["CMOS", "C-MOS", "OOCYTE MATURATION FACTOR MOS"],
    "POMC": ["POMC", "PROOPIOMELANOCORTIN"],
    "TYR": ["TYR", "TYROSINASE"],
    "RHO": ["RHO", "RHODOPSIN"],
    "SIAH1": ["SIAH1", "SEVEN IN ABSENTIA 1", "SEVEN IN ABSENTIA-LIKE PROTEIN 1"],
    "CRYB": ["CRYB", "CRYBA1", "BETA-CRYSTALLIN", "BETA CRYSTALLIN"],
    "TNS3": ["TNS3", "TENSIN 3"],
    "S7": ["S7", "S7 RIBOSOMAL PROTEIN", "40S RIBOSOMAL PROTEIN S7"],
    "TYRP1": ["TYRP1", "TYROSINASE-RELATED PROTEIN 1"],
    "EIF3": ["EIF3", "EUKARYOTIC TRANSLATION INITIATION FACTOR 3"],
    "CXCR4": ["CXCR4", "CHEMOKINE RECEPTOR"],
    "NT3": ["NT3", "NEUROTROPHIN 3"],
    "FIB7": ["FGBI7", "FIBRINOGEN BETA CHAIN INTERGENIC", "FIB7"],
    "MYH6": ["MYH6", "ALPHA MYOSIN HEAVY CHAIN"],
    "CMYC": ["CMYC", "C-MYC", "MYC PROTO-ONCOGENE"],
    "CMYC2": ["CMYC2", "MYC 2ND COPY"],
    "H3A": ["H3A", "HISTONE H3", "H3", "HISTONE 3"],
    "ZEB2": ["ZEB2", "ZINC FINGER E-BOX BINDING HOMEBOX 2"],
    "MC1R": ["MC1R", "MELANOCORTIN 1 RECEPTOR"],
    "SNCAIP": ["SNCAIP", "ALPHA-SYNUCLEIN INTERACTING PROTEIN"],
    "PTPRC": ["PTPRC", "PROTEIN TYROSINE PHOSPHATASE RECEPTOR TYPE C"],
    "OPA1": ["OPA1", "OPA1 MITOCHONDRIAL DYNAMIN LIKE GTPASE"]
} # ← Mitocondria e nucleares animal

alias_map_mito_planta = {
    "26S": ["26S RIBOSOMAL RNA", "RRN26", "26S", "26S RRN", "26SRRNA", "26 S RIBOSOMAL RNA", "26S RRNA", "RRNA-26S", "26S RIBOSORMAL RNA", "26S-RRNA"],
    "ATP1": ["ATP1", "ATPASE SUBUNIT A", "ATPASE SUBUNIT 1", "ATP SYNTHASE F1 SUBUNIT 1", "ATP SYNTHASE F1 SUBUNIT ALPHA"],
    "ATP4": ["ATP4", "ATPASE SUBUNIT 4"],
    "ATP6": ["ATP6", "ATPASE6", "ATPASE 6", "ATP SYNTHASE 6", "ATP SYNTHASE SUBUNIT 6", "ATP SYNTHASE F0 SUBUNIT 6", "ATPASE SUBUNIT 6", "MT-ATP6", "F0-ATP SYNTHASE SUBUNIT6", "ATP SYTHASE SUBUNIT 6", "AT6", "MTATP6"],
    "ATP6-1": ["ATP6-1"],
    "ATP6-2": ["ATP6-2"],
    "ATP8": ["ATP8", "ATPASE8", "ATPASE 8", "ATP SYNTHASE 8", "ATP SYNTHASE SUBUNIT 8", "ATP SYNTHASE F0 SUBUNIT 8", "ATPASE SUBUNIT 8", "MT-ATP8", "F0-ATP SYNTHASE SUBUNIT8", "ATP SYTHASE SUBUNIT 8", "AT8", "MTATP8"],
    "ATP9": ["ATP9", "ATPASE SUBUNIT 9", "ATP SYNTHASE F0 SUBUNIT 9"],
    "COI": ["CYTOCHROME C OXIDASE SUBUNIT 1", "COI", "COX1", "CO1", "COXI", "CYTOCHROME C OXIDASE SUBUNIT I", "COX-I", "MT-CO1", "CYTOCHROME OXIDASE C SUBUNIT 1", "CYTOCHROME OXIDASE SUBUNIT 1", "CYTOCHROME OXIDASE SUBUNIT1", "CYTOCHROME C OXIDASE SUBUNIT1", "CO I", "CYTOCHROME OXIDASE I", "CYTOCHROME OXIDASE SUBUNIT I", "COX I"],
    "COII": ["CYTOCHROME C OXIDASE SUBUNIT 2", "COII", "COX2", "COXII", "CO2", "CYTOCHROME C OXIDASE SUBUNIT II", "COX-II", "MT-CO2", "CYTOCHROME OXIDASE SUBUNIT 2", "CYTOCHROME OXIDASE SUBUNIT2", "CYTOCHROME C OXIDASE SUBUNIT2", "CO II", "CYTOCHROME OXIDASE II", "CYTOCHROME OXIDASE SUBUNIT II", "COX II"],
    "COII-1": ["COX2-1", "CYTOCHROME C OXIDASE SUBUNIT 2-1"],
    "COIII": ["CYTOCHROME C OXIDASE SUBUNIT 3", "COIII", "COX3", "CO3", "COXIII", "CYTOCHROME C OXIDASE SUBUNIT III", "COX-III", "MT-CO3", "CYTOCHROME OXIDASE C SUBUNIT 3", "CYTOCHROME OXIDASE SUBUNIT 3", "CYTOCHROME OXIDASE SUBUNIT3", "CYTOCHROME C OXIDASE SUBUNIT3", "CO III", "CYTOCHROME OXIDASE III", "CYTOCHROME OXIDASE SUBUNIT III", "CO3 SUBUNIT 3", "COX III"],
    "CYTB": ["CYTB", "COB", "CYT B", "CB", "CYTOCHROME B", "CYB", "MT-CYB", "CYT-B", "MT-CYTB", "CYTOCHOROME B", "CTYB", "APOCYTOCHROME B"],
    "L16": ["RPL16", "RIBOSOMAL PROTEIN L16"],
    "ND1": ["ND1", "NADH1", "NADH DEHYDROGENASE SUBUNIT 1", "NAD1", "MT-ND1", "NADH-1", "MTND1", "NADH DEHYDROGENASE SUBUNIT1", "NADH SUBUNIT 1", "NADH DEHYDROGENASE 1", "NADH DEHYDROGENASE SUBUNIT I"],
    "ND2": ["ND2", "NADH2", "NADH DEHYDROGENASE SUBUNIT 2", "NAD2", "NADH DEHYDROGENASE SUBUNIT II", "NADH SUBUNIT 2", "MT-ND2", "NADH DEHYDROGENASE SUBUNIT2"],
    "ND3": ["ND3", "NADH3", "NADH DEHYDROGENASE SUBUNIT 3", "NAD3", "MT-ND3", "NADH DEHYDROGENASE SUBUNIT3", "NADH SUBUNIT 3", "NADH DEHYDROGENASE SUBUNIT III"],
    "ND4": ["ND4", "NADH4", "NADH DEHYDROGENASE SUBUNIT 4", "NAD4", "MT-ND4", "NADH DEHYDROGENASE SUBUNIT4", "4", "NADH SUBUNIT 4", "NADH DEHYDROGENASE SUBUNIT IV"],
    "ND4L": ["ND4L", "NADH4L", "NADH DEHYDROGENASE SUBUNIT 4L", "NAD4L", "MT-ND4L", "NADH DEHYDROGENASE SUBUNIT 4 L", "NADH DEHYDROGENASE SUBUNIT4L", "NADH SUBUNIT 4L", "NADH DEHYDROGENASE SUBUNIT IV L"],
    "ND5": ["ND5", "NADH5", "NADH DEHYDROGENASE SUBUNIT 5", "NAD5", "MT-ND5", "NADH DEHYDROGENASE SUBUNIT5", "NADH SUBUNIT 5", "NADH DEHYDROGENASE SUBUNIT V"],
    "ND6": ["ND6", "NADH6", "NADH DEHYDROGENASE SUBUNIT 6", "NAD6", "MT-ND6", "NADH DEHYDROGENASE SUBUNIT6", "NADH SUBUNIT 6", "NADH DEHYDROGENASE SUBUNIT VI"],
    "ND7": ["NAD7", "NADH DEHYDROGENASE SUBUNIT 7"],
    "ND9": ["ND9", "NADH9", "NADH DEHYDROGENASE SUBUNIT 9", "NAD9", "MT-ND9", "NADH DEHYDROGENASE SUBUNIT9", "NADH SUBUNIT 9"],
    "PsaA": ["PSAA"],
    "S1": ["RPS1", "RIBOSOMAL PROTEIN S1"],
    "S10": ["RIBOSOMAL PROTEIN S10", "RPS10"],
    "S13": ["RPS13", "RIBOSOMAL PROTEIN S13"],
    "S19": ["RPS19", "RIBOSOMAL PROTEIN S19"],
    "SDH3": ["SDH3", "SUCCINATE DEHYDROGENASE SUBUNIT 3"],
    "ccmB": ["CCMB", "CCB2", "CCB206", "CYTOCHROME C BIOGENESIS CCMB", "CYTOCHROME C BIOGENESIS B"],
    "ccmC": ["CCMC", "CYTOCHROME C BIOGENSIS PROTEIN C", "CYTOCHROME C BIOGENESIS CCMC", "CYTOCHROME C BIOGENESIS C"],
    "ccmFC": ["CCMFC", "CYTOCHROME C BIOGENESIS CCMF", "CYTOCHROME C BIOGENESIS FC"],
    "ccmFN1": ["CCMFN1", "CB6N1", "CCB382", "CYTOCHROME C BIOGENESIS PROTEIN FN1", "CCMFN-1"],
    "ccmFN2": ["CCMFN2", "CCB203", "CCB6N2", "CYTOCHROME C BIOGENESIS PROTEIN FN2"],
    "ccmFn": ["CCMFN", "CYTOCHROME C BIOGENESIS FN"],
    "matR": ["MATR", "MATURASE PROTEIN", "MAT-R"],
    "rbcL": ["RBCL"],
    "rpl10": ["RPL10", "RIBOSOMAL PROTEIN L10"],
    "rpl2": ["RPL2", "RIBOSOMAL PROTEIN L2"],
    "rpl5": ["RPL5", "RIBOSOMAL PROTEIN L5"],
    "rpoB": ["RPOB", "RNA POLYMERASE SUBUNIT BETA", "RNA POLYMERASE BETA SUBUNIT"],
    "rps12": ["RPS12", "RIBOSOMAL PROTEIN S12"],
    "rps14": ["RPS14", "RIBOSOMAL PROTEIN S14"],
    "rps3": ["RPS3", "RIBOSOMAL PROTEIN S3"],
    "rps4": ["RPS4", "RIBOSOMAL PROTEIN S4"],
    "rps7": ["RPS7", "RIBOSOMAL PROTEIN S7"],
    "rrn18": ["RRN18", "18S RIBOSOMAL RNA"],
    "rrn5": ["RRN5", "5S RIBOSOMAL RNA"],
    "tRNA-Arg": ["TRNA-ARG", "TRNA_ARG", "TRNR", "TRNR(TCT)"],
    "tRNA-Asn": ["TRNA-ASN", "TRNA_ASN", "TRNN", "TRNN-GUU", "TRNN GTT", "TRNN(GTT)", "TRNN(GUU)"],
    "tRNA-Asp": ["TRNA-ASP", "TRNA_ASP", "TRND", "TRND-GUC", "TRND GTC", "TRND(GTC)", "TRND(GUC)"],
    "tRNA-Cys": ["TRNA-CYS", "TRNA_CYS", "TRNC", "TRNC-GCA", "TRNC GCA", "TRNC(GCA)"],
    "tRNA-Gln": ["TRNA-GLN", "TRNA_GLN", "TRNQ", "TRNQ-UUG", "TRNQ TTG", "TRNQ(TTG)", "TRNQ(UUG)"],
    "tRNA-Glu": ["TRNA-GLU", "TRNA_GLU", "TRNE", "TRNE-UUC", "TRNE TTC", "TRNE(TTC)", "TRNE(UUC)"],
    "tRNA-Gly": ["TRNA-GLY", "TRNA_GLY", "TRNG", "TRNG-UCC", "TRNG TCC"],
    "tRNA-His": ["TRNA-HIS", "TRNA_HIS", "TRNH", "TRNH-GUG", "TRNH GTG", "TRNH(GTG)", "TRNH(GUG)"],
    "tRNA-Ile": ["TRNA-ILE", "TRNA_ILE", "TRNI", "TRNI-CAU", "TRNI(CAT)", "TRNI(CAU)"],
    "tRNA-Leu": ["TRNA-LEU", "TRNA_LEU", "TRNL", "TRNL-CAA"],
    "tRNA-Lys": ["TRNA-LYS", "TRNA_LYS", "TRNK", "TRNK-UUU", "TRNK TTT", "TRNK(TTT)", "TRNK(UUU)"],
    "tRNA-Met": ["TRNA-MET", "TRNA_MET", "TRNM", "TRNM-CAU", "TRNM CAT", "TRNM(CAT)"],
    "tRNA-Phe": ["TRNA-PHE", "TRNA_PHE", "TRNF-GAA", "TRNF GAA", "TRNF", "TRNF(GAA)"],
    "tRNA-Pro": ["TRNA-PRO", "TRNA_PRO", "TRNP-UGG", "TRNP TGG", "PROLINE TRNA", "TRNP", "TRNP(TGG)", "TRNP(UGG)"],
    "tRNA-Ser": ["TRNA-SER", "TRNA_SER", "TRNS", "TRNS(GGA)", "TRNS(GCT)", "TRNS(UGA)", "TRNS(GCU)"],
    "tRNA-Trp": ["TRNA-TRP", "TRNA_TRP", "TRNW", "TRNW-CCA", "TRNW(CCA)"],
    "tRNA-Tyr": ["TRNA-TYR", "TRNA_TYR", "TRNY", "TRNY-GUA", "TRNY GTA", "TRNY(GTA)", "TRNY(GUA)"],
    "tRNA-fMet": ["TRNA-FMET", "TRNFM-CAU", "TRNFM(CAT)", "TRNFM(CAU)"],
    "tatC": ["TATC", "TWIN ARGININE TRANSLOCATION", "TWIN-ARGININE TRANSLOCASE SUBUNIT TATC"],
    "ycf1": ["YCF1"],
    "ycf2": ["YCF2"]
} # ← Mitocondria vegetal

alias_map_cloroplasto = {
    "accD": ["ACCD", "ACETYL-COA CARBOXYLASE CARBOXYLTRANSFERASE", "ACETYL-COA CARBOXYLASE CARBOXYLTRANSFERASE BETA SUBUNIT", "ACETYL-COA CARBOXYLASE, CARBOXYL TRANSFERASE SUBUNIT BETA", "BETA SUBUNIT OF ACETYL-COA CARBOXYLASE"],
    "atpA": ["ATPA", "ATP SYNTHASE CF1 ALPHA SUBUNIT"],
    "atpB": ["ATPB", "ATP SYNTHASE CF1 BETA SUBUNIT", "ATPASE BETA CHAIN"],
    "atpE": ["ATPE", "ATP SYNTHASE CF1 EPSILON SUBUNIT", "ATP SYNTHASE EPSILON CHAIN"],
    "atpF": ["ATPF", "ATP SYNTHASE CF0 SUBUNIT I"],
    "atpH": ["ATPH", "ATP SYNTHASE CF0 SUBUNIT III", "ATPASE III SUBUNIT", "ATP SYNTHASE SUBUNIT III"],
    "atpI": ["ATPI", "ATP SYNTHASE CF0 SUBUNIT IV"],
    "ccsA": ["CCSA", "YCF5"],
    "cemA": ["CEMA", "CHLOROPLAST ENVELOPE MEMBRANE PROTEIN", "HEME-BINDING PROTEIN", "ENVELOPE MEMBRANE PROTEIN", "CHLOROPLAST ENVELOPE PROTEIN", "YCF10"],
    "clpP": ["CLPP", "CLP PROTEASE PROTEOLYTIC SUBUNIT", "ATP-DEPENDENT PROTEASE PROTEOLYTIC SUBUNIT", "CLP PROTEASE PROTEOLYTIC"],
    "matK": ["MATK", "MATURASE", "MAT", "MATURASE K"],
    "ndhA": ["NDHA"],
    "ndhB": ["NDHB", "NADH DEHYDROGENASE SUBUNIT 2", "NADH-PLASTOQUINONE OXIDOREDUCTASE SUBUNIT 2"],
    "ndhC": ["NDHC", "NADH DEHYDROGENASE SUBUNIT 3", "NADH-PLASTOQUINONE OXIDOREDUCTASE SUBUNIT 3"],
    "ndhD": ["NDHD", "NADH DEHYDROGENASE SUBUNIT 4", "NDH4", "NADH-PLASTOQUINONE OXIDOREDUCTASE SUBUNIT 4"],
    "ndhE": ["NDHE", "NADH DEHYDROGENASE SUBUNIT 4L", "NDH4L", "NADH-PLASTOQUINONE OXIDOREDUCTASE SUBUNIT 4L"],
    "ndhF": ["NDHF", "NADH DEHYDROGENASE SUBUNIT 5", "NADH-PLASTOQUINONE OXIDOREDUCTASE SUBUNIT 5"],
    "ndhG": ["NDHG", "NADH DEHYDROGENASE SUBUNIT 6", "NADH-PLASTOQUINONE OXIDOREDUCTASE SUBUNIT 6"],
    "ndhH": ["NDHH", "NADH-PLASTOQUINONE OXIDOREDUCTASE SUBUNIT 7", "NADH DEHYDROGENASE SUBUNIT 7"],
    "ndhI": ["NDHI", "NDHL"],
    "ndhJ": ["NDHJ", "NADH DEHYDROGENASE SUBUNIT J", "NADH-PLASTOQUINONE OXIDOREDUCTASE SUBUNIT J"],
    "ndhK": ["NDHK", "NADH DEHYDROGENASE SUBUNIT K", "NADH-PLASTOQUINONE OXIDOREDUCTASE SUBUNIT K"],
    "pafI": ["PAFI", "YCF3", "PHOTOSYSTEM I ASSEMBLY FACTOR I", "PUTATIVE CHLOROPLAST RF34"],
    "pafII": ["PAFII", "YCF4", "PHOTOSYSTEM I ASSEMBLY PROTEIN YCF4", "PHOTOSYSTEM I ASSEMBLY FACTOR II"],
    "petA": ["PETA", "CYTOCHROME F", "APOCYTOCHROME F"],
    "petB": ["PETB", "CYTOCHROME B6"],
    "petD": ["PETD", "CYTOCHROME B6/F COMPLEX SUBUNIT IV", "CYTOCHROME B6/F COMPLEX SUBUNIT 4", "SUBUNIT IV OF CYTOCHROME B6/F COMPLEX"],
    "petG": ["PETG", "CYTOCHROME B6/F COMPLEX SUBUNIT V", "CYTOCHROME B6-F COMPLEX SUBUNIT 5"],
    "petL": ["PETL", "CYTOCHROME B6/F COMPLEX SUBUNIT VI", "SUBUNIT VI OF CYTOCHROME B6/F COMPLEX", "YCF7"],
    "petN": ["PETN", "CYTOCHROME B6/F COMPLEX SUBUNIT VIII", "CYTOCHROME B6F COMPLEX SUBUNIT VIII", "YCF6"],
    "psaA": ["PSAA", "PHOTOSYSTEM I P700 APOPROTEIN A1", "PSI P700 APOPROTEIN A1"],
    "psaB": ["PSAB", "PHOTOSYSTEM I P700 APOPROTEIN A2", "PSI P700 APOPROTEIN A2", "PHOTOSYSTEM I P700 CHLOROPHYLL A APOPROTEIN A2"],
    "psaC": ["PSAC", "PHOTOSYSTEM I IRON-SULFUR CENTER", "PHOTOSYSTEM I SUBUNIT VII", "SUBUNIT VII OF PHOTOSYSTEM I", "PSI C PROTEIN", "PHOTOSYSTEM I IRON-SULFUR CENTER SUBUNIT VII"],
    "psaI": ["PSAI", "PHOTOSYSTEM I SUBUNIT VIII", "PHOTOSYSTEM I REACTION CENTER SUBUNIT VIII"],
    "psaJ": ["PSAJ", "PSI J-PROTEIN", "PHOTOSYSTEM I SUBUNIT IX", "PHOTOSYSTEM I REACTION CENTER SUBUNIT IX", "PHOTOSYSTEM I PROTEIN J"],
    "psb30": ["PSB30", "PHOTOSYSTEM II PROTEIN PSB30", "YCF12", "PHOTOSYSTEM II REACTION CENTRE PROTEIN YCF12"],
    "psbA": ["PSBA", "PHOTOSYSTEM II PROTEIN D1"],
    "psbB": ["PSBB", "PHOTOSYSTEM II 47 KDA PROTEIN", "PHOTOSYSTEM II P680 CHLOROPHYLL A APOPROTEIN", "PHOTOSYSTEM II CP47 CHLOROPHYLL APOPROTEIN"],
    "psbC": ["PSBC", "PHOTOSYSTEM II CP43 CHLOROPHYLL APOPROTEIN"],
    "psbD": ["PSBD", "PHOTOSYSTEM II PROTEIN D2", "PSII D2 PROTEIN"],
    "psbE": ["PSBE", "CYTOCHROME B559 ALPHA SUBUNIT OF PHOTOSYSTEM", "CYTOCHROME B559 ALPHA CHAIN", "PHOTOSYSTEM II CYTOCHROME B559 ALPHA SUBUNIT", "PHOTOSYSTEM II PROTEIN V"],
    "psbF": ["PSBF", "PHOTOSYSTEM II CYTOCHROME B559 BETA SUBUNIT", "PHOTOSYSTEM II PROTEIN VI", "PSII SUBUNIT VI"],
    "psbH": ["PSBH", "PHOTOSYSTEM II PHOSPHOPROTEIN", "PHOTOSYSTEM II REACTION CENTER PROTEIN H", "PHOTOSYSTEM II PROTEIN H", "PSII 10 KDA PHOSPHOPROTEIN"],
    "psbI": ["PSBI", "PHOTOSYSTEM II PROTEIN I"],
    "psbJ": ["PSBJ", "PHOTOSYSTEM II PROTEIN J", "J PROTEIN OF PHOTOSYSTEM II"],
    "psbK": ["PSBK", "PHOTOSYSTEM II PROTEIN K", "PSII K PROTEIN"],
    "psbL": ["PSBL", "PHOTOSYSTEM II PROTEIN L"],
    "psbM": ["PSBM", "PHOTOSYSTEM II PROTEIN M", "PHOTOSYSTEM II M PROTEIN"],
    "psbN": ["PSBN", "PHOTOSYSTEM II PROTEIN N", "PHOTOSYSTEM II REACTION CENTER N PROTEIN", "N PROTEIN OF PHOTOSYSTEM II", "PSII N PROTEIN"],
    "psbT": ["PSBT", "PHOTOSYSTEM II PROTEIN T", "T PROTEIN OF PHOTOSYSTEM II", "YCF8"],
    "psbZ": ["PSBZ", "PHOTOSYSTEM II PROTEIN Z", "PHOTOSYSTEM II REACTION CENTER Z PROTEIN", "YCF9"],
    "rbcL": ["RBCL", "RIBULOSE 1,5-BISPHOSPHATE CARBOXYLASE/OXYGENASE", "RUBISCO LARGE SUBUNIT", "LARGE SUBUNIT OF RUBISCO"],
    "rpl12": ["RPL12", "RIBOSOMAL PROTEIN L2"],
    "rpl14": ["RPL14", "RIBOSOMAL PROTEIN L14"],
    "rpl16": ["RPL16", "RIBOSOMAL PROTEIN L16"],
    "rpl20": ["RPL20", "RIBOSOMAL PROTEIN L20"],
    "rpl22": ["RPL22", "RIBOSOMAL PROTEIN L22"],
    "rpl32": ["RPL32", "RIBOSOMAL PROTEIN L32"],
    "rpl33": ["RPL33", "RIBOSOMAL PROTEIN L33"],
    "rpl36": ["RPL36", "RIBOSOMAL PROTEIN L16"],
    "rpoA": ["RPOA", "RNA POLYMERASE ALPHA SUBUNIT", "RNA POLYMERASE ALPHA CHAIN", "RNA POLYMERASE A-SUBUNIT"],
    "rpoB": ["RPOB", "RNA POLYMERASE BETA SUBUNIT"],
    "rpoC1": ["RPOC1", "RNA POLYMERASE BETA' SUBUNIT"],
    "rpoC2": ["RPOC2", "RNA POLYMERASE BETA'' SUBUNIT"],
    "rps11": ["RPS11", "RIBOSOMAL PROTEIN S11"],
    "rps12": ["RPS12", "RIBOSOMAL PROTEIN S12"],
    "rps14": ["RPS14", "RIBOSOMAL PROTEIN S14"],
    "rps15": ["RPS15", "RIBOSOMAL PROTEIN S15"],
    "rps16": ["RPS16", "RIBOSOMAL PROTEIN S16"],
    "rps18": ["RPS18", "RIBOSOMAL PROTEIN S18"],
    "rps19": ["RPS19", "RIBOSOMAL PROTEIN S19"],
    "rps2": ["RPS2", "RIBOSOMAL PROTEIN S2"],
    "rps3": ["RPS3", "RIBOSOMAL PROTEIN S3"],
    "rps4": ["RPS4", "RIBOSOMAL PROTEIN S4"],
    "rps7": ["RPS7", "RIBOSOMAL PROTEIN S7"],
    "rps8": ["RPS8", "RIBOSOMAL PROTEIN S8"],
    "rrn16": ["RRN16", "16S RIBOSOMAL RNA"],
    "rrn23": ["RRN23", "23S RIBOSOMAL RNA"],
    "rrn4_5": ["RRN4.5", "4.5S RIBOSOMAL RNA"],
    "rrn5": ["RRN5", "5S RIBOSOMAL RNA"],
    "trnA": ["TRNA-UGC", "TRNA-ALA"],
    "trnC": ["TRNC-GCA", "TRNA-CYS"],
    "trnD": ["TRND-GUC", "TRNA-ASP"],
    "trnE": ["TRNE-UUC", "TRNA-GLU"],
    "trnF": ["TRNF-GAA", "TRNA-PHE"],
    "trnG": ["TRNG-UCC", "TRNA-GLY"],
    "trnH": ["TRNH-GUG", "TRNA-HIS"],
    "trnI": ["TRNI-CAU", "TRNI-GAU", "TRNI-GAT", "TRNA-ILE"],
    "trnK": ["TRNK-UUU", "TRNA-LYS"],
    "trnL": ["TRNL-UAA", "TRNL-CAA", "TRNL-UAG", "TRNA-LEU"],
    "trnM": ["TRNM-CAU", "TRNA-MET"],
    "trnN": ["TRNN-GUU", "TRNA-ASN"],
    "trnP": ["TRNP-UGG", "TRNA-PRO"],
    "trnQ": ["TRNQ-UUG", "TRNA-GLN"],
    "trnR": ["TRNR-UCU", "TRNR-ACG", "TRNA-ARG"],
    "trnS": ["TRNS-GCU", "TRNS-UGA", "TRNS-GGA", "TRNA-SER"],
    "trnT": ["TRNT-GGU", "TRNT-UGU", "TRNA-THR"],
    "trnV": ["TRNV-UAC", "TRNV-GAC", "TRNA-VAL"],
    "trnW": ["TRNW-CCA", "TRNA-TRP"],
    "trnY": ["TRNY-GUA", "TRNA-TYR"],
    "trnfM": ["TRNFM-CAU"],
    "ycf1": ["YCF1", "HYPOTHETICAL CHLOROPLAST RF1"],
    "ycf15": ["YCF15"],
    "ycf2": ["YCF2"]
} # ← Cloroplasto vegetal

# ================================================================

import tkinter as tk
from tkinter import messagebox, Toplevel, Label, Checkbutton, BooleanVar, Button, Entry, ttk, Tk, DoubleVar, StringVar
import os
import re
import traceback
from Bio import Entrez, SeqIO
from openpyxl import Workbook
from collections import defaultdict
from tqdm import tqdm
from pathlib import Path
import threading
import logging
import unicodedata

Entrez.email = "felipemm17@gmail.com"
Entrez.api_key = "8ccf2aa69a00f2eab2f1eafa1133c1bb9009"

valid_fields = [
    "organism", "isolate", "specimen_voucher", "country", "collection_date",
    "host", "strain", "isolation_source", "lat_lon"
]

# Genes principais apenas para exibição amigável
GENES_MITO_ANIMAL_PRINCIPAIS = [
    "12S", "16S", "ATP6", "ATP8", "COI", "COII", "COIII",
    "CYTB", "ND1", "ND2", "ND3", "ND4", "ND4L", "ND5", "ND6",
]

GENES_MITO_PLANTA_PRINCIPAIS = [
    "26S", "ATP1", "ATP4", "ATP6", "ATP8", "ATP9", "COI", "COII", "COIII",
    "CYTB", "ND1", "ND2", "ND3", "ND4", "NADL", "ND5", "ND6",
    "ND7", "ND9", "MATR", "RPS3", "L16"
]

GENES_CLOROPLASTO_PRINCIPAIS = [
    "RBCL", "MATK", "PSBA", "PSBB", "PSBC", "PSBD", "ATPA", "ATPB",
    "NDHA", "NDHB", "NDHC", "NDHD", "NDHE", "NDHF", "NDHG", "NDHI", "NDHK",
    "YCF1", "YCF2", "RPOA", "RPOB", "RPOC1", "RPOC2", "CLPP", "ACCD"
]

def show_field_selector(entry_widget):
    modal = Toplevel(entry_widget.winfo_toplevel())
    modal.title("Selecionar campos do cabeçalho")
    modal.geometry("300x400")
    Label(modal, text="Selecione os campos para o cabeçalho:").pack(pady=5)
    Label(modal, text="Pelo menos um campo obrigatório (default: organism)", fg="gray", font=("Arial", 12, "italic")).pack(pady=(0, 10))
    check_vars = {field: BooleanVar(value=(field.lower() == "organism")) for field in valid_fields}
    for field in valid_fields:
        cb = Checkbutton(modal, text=field, variable=check_vars[field])
        cb.pack(anchor="w")
    def apply_selection():
        selected = [f for f, var in check_vars.items() if var.get()]
        entry_widget.delete(0, tk.END)
        entry_widget.insert(0, ", ".join(selected))
        modal.destroy()
    Button(modal, text="Aplicar", command=apply_selection).pack(pady=10)

def show_gene_selector(entry_widget, org_type):
    # Escolhe alias_map e lista principal com base no tipo selecionado
    if org_type == "animal_mito":
        alias_map = alias_map_animal
        lista_alvo = GENES_MITO_ANIMAL_PRINCIPAIS
    elif org_type == "planta_mito":
        alias_map = alias_map_mito_planta
        lista_alvo = GENES_MITO_PLANTA_PRINCIPAIS
    elif org_type == "planta_cloro":
        alias_map = alias_map_cloroplasto
        lista_alvo = GENES_CLOROPLASTO_PRINCIPAIS
    else:
        alias_map = {}
        lista_alvo = []

    # Garante que os nomes exibidos são os mesmos das chaves reais do alias_map
    genes_disponiveis = []
    for g in lista_alvo:
        for k in alias_map:
            if g.upper() == k.upper():
                genes_disponiveis.append(k)
                break

    # Monta a janela
    modal = Toplevel(entry_widget.winfo_toplevel())
    modal.title("Selecionar genes")
    modal.geometry("600x480")

    Label(modal, text="Selecione os genes que deseja buscar:").pack(pady=5)
    Label(modal, text="💡 Apenas os nomes principais são exibidos.\nOs sinônimos serão aplicados automaticamente na busca.").pack(pady=2)

    frame_genes = tk.Frame(modal)
    frame_genes.pack(padx=10, pady=10)

    vars_dict = {}
    for i, gene in enumerate(sorted(genes_disponiveis)):
        var = BooleanVar()
        cb = Checkbutton(frame_genes, text=gene, variable=var)
        cb.grid(row=i % 8, column=i // 8, sticky="w", padx=5, pady=2)
        vars_dict[gene] = var

    def apply_selection():
        selected = [g for g, v in vars_dict.items() if v.get()]
        entry_widget.delete(0, tk.END)
        entry_widget.insert(0, ", ".join(selected))
        modal.destroy()

    Button(modal, text="Aplicar", command=apply_selection).pack(pady=10)
            
def search_genbank(query):
    try:
        with Entrez.esearch(db="nucleotide", term=query, retmax=100000) as search_handle:
            search_results = Entrez.read(search_handle)
            return search_results["IdList"]
    except Exception as e:
        messagebox.showerror("Erro", f"Erro ao buscar: {e}")
        return []
                  
def classificar_posicional_ser(start, ref_pos_all, tolerancia_bp=10):
    pos_coi_end = min([p for g, ps in ref_pos_all.items() if g.upper() == "COI" for p in ps], default=float('inf'))
    pos_nd4_end = max([p for g, ps in ref_pos_all.items() if g.upper() == "ND4" for p in ps], default=-1)

    if pos_coi_end == float('inf') or pos_nd4_end == -1:
        return "tRNA-Ser_unclassified"

    if (pos_coi_end - tolerancia_bp) <= start <= pos_nd4_end:
        return "tRNA-Ser_between_COI_ND4"
    elif start > pos_nd4_end:
        return "tRNA-Ser_after_ND4"
    else:
        return "tRNA-Ser_unclassified"
        
def classificar_posicional_leu(start, ref_pos_all):
    # Considera apenas genes principais (CDS e rRNA), ignora tRNAs
    anchors = sorted(
        [(gene, pos) for gene, pos_list in ref_pos_all.items()
         if not gene.upper().startswith("TRNA") for pos in pos_list],
        key=lambda x: x[1]
    )

    for gene, pos in anchors:
        if start < pos:
            return f"tRNA-Leu_before_start_{gene}"

    return "tRNA-Leu_unclassified"

def extrair_genes_geral(record, header_id, alias_map, genes_desejados, seen_genes, gene_dict, aliases_desconhecidos, aliases_duplicados, agrupador_leu, agrupador_ser, seen_leu_ser):

    original_id = record.annotations.get("original_id", record.id)

    alias_lookup = {}
    for main_name, aliases in alias_map.items():
        alias_lookup[main_name.upper()] = main_name
        for alias in aliases:
            alias_lookup[alias.upper()] = main_name

    genes_desejados_set = {g.upper() for g in genes_desejados} if genes_desejados else None

    ref_pos = {}
    ref_pos_all = {}
    for feature in record.features:
        if feature.type not in ["gene", "CDS", "rRNA", "tRNA"]:
            continue

        nome_bruto = None
        for key in ["gene", "product", "note"]:
            if key in feature.qualifiers:
                nome_bruto = feature.qualifiers[key][0].strip()
                break
        if not nome_bruto:
            continue

        nome_bruto_upper = nome_bruto.upper()
        gene = None
        for main_name, aliases in alias_map.items():
            all_names = [main_name.upper()] + [a.upper() for a in aliases]
            if nome_bruto_upper in all_names:
                gene = main_name
                break
        if not gene:
            continue

        pos = int(feature.location.start)
        if gene in ["12S", "16S", "ND1", "ND2", "COI", "ND4"] and gene not in ref_pos:
            ref_pos[gene] = pos

        if gene not in ref_pos_all:
            ref_pos_all[gene] = []
        ref_pos_all[gene].append(pos)

    for feature in record.features:
        if feature.type not in ["gene", "CDS", "rRNA", "tRNA"]:
            continue

        raw_name = None
        for key in ["gene", "product", "note"]:
            if key in feature.qualifiers:
                raw_name = feature.qualifiers[key][0]
                break
        if not raw_name:
            continue

        raw_name = unicodedata.normalize("NFKC", raw_name).strip()
        raw_upper = raw_name.upper()
        name = alias_lookup.get(raw_upper)
        if not name:
            aliases_desconhecidos.add(raw_name)
            continue

        if genes_desejados_set and name.upper() not in genes_desejados_set:
            continue

        start = int(feature.location.start)
        end = int(feature.location.end)
        strand = feature.location.strand
        seq = record.seq[start:end]
        if strand == -1:
            seq = seq.reverse_complement()

        if name.upper() == "TRNA-LEU":
            tag = classificar_posicional_leu(start, ref_pos_all)
            chave = (original_id, name, tag)
            if chave not in seen_leu_ser:
                agrupador_leu[tag].append((header_id, str(seq), original_id))
                seen_leu_ser.add(chave)
            continue

        elif name.upper() == "TRNA-SER":
            tag = classificar_posicional_ser(start, ref_pos_all)
            chave = (original_id, name, tag)
            if chave not in seen_leu_ser:
                agrupador_ser[tag].append((header_id, str(seq), original_id))
                seen_leu_ser.add(chave)
            continue

        if (original_id, name) in seen_genes:
            aliases_duplicados.add(name)
            continue

        if name not in gene_dict:
            gene_dict[name] = []
        gene_dict[name].append((header_id, str(seq), original_id))
        seen_genes.add((original_id, name))

    gene_dict.pop("tRNA-Leu", None)
    gene_dict.pop("tRNA-Ser", None)

def corrigir_sobreposicoes_em_animais(record, gene_dict, alias_map, gene_folder):
    import os

    original_id = record.annotations.get("original_id", record.id)
    nome = record.annotations.get("organism", "Unknown")
    header_id = f"{original_id}"

    gene_coords = []
    for feature in record.features:
        if feature.type not in ["gene", "CDS", "rRNA"]:
            continue

        raw_name = None
        for key in ["gene", "product", "note"]:
            if key in feature.qualifiers:
                raw_name = feature.qualifiers[key][0]
                break

        if not raw_name:
            continue

        raw_upper = raw_name.upper()
        name = None
        for main_name, aliases in alias_map.items():
            if raw_upper == main_name.upper() or raw_upper in map(str.upper, aliases):
                name = main_name
                break

        if not name:
            continue

        start = int(feature.location.start)
        end = int(feature.location.end)
        strand = feature.location.strand

        gene_coords.append((name, start, end, strand, feature))

    gene_coords.sort(key=lambda x: x[1])
    log_registros = []

    for i in range(len(gene_coords) - 1):
        name, start, end, strand, _ = gene_coords[i]
        next_name, next_start, next_end, _, _ = gene_coords[i + 1]

        if name != next_name and end > next_start:
            overlap = end - next_start
            log_registros.append((name, start, end, next_name, next_start, next_end, overlap))

            novas_entradas = []
            for header, seq, orig_id in gene_dict.get(name, []):
                if orig_id != original_id:
                    novas_entradas.append((header, seq, orig_id))
                    continue

                if strand == 1:
                    seq_corrigida = seq[:next_start - start]
                else:
                    corte = end - next_start
                    seq_corrigida = seq[corte:]

                novas_entradas.append((header, seq_corrigida, orig_id))

            gene_dict[name] = novas_entradas

    if log_registros:
        log_path = os.path.join(gene_folder, "sobreposicoes.log")
        with open(log_path, "a") as logf:
            chave = f"{nome} ({header_id})"
            logf.write(f"[{chave}]\n")
            for g1, s1, e1, g2, s2, e2, o in log_registros:
                logf.write(f"⚠️ {g1} ({s1}..{e1}) sobrepõe {g2} ({s2}..{e2}): {o} bp removidos do final de {g1}\n")
            logf.write("\n")
    
def gerar_excel_metadados_por_gene(gene_dict, excel_data, header_fields, output_base):
    header_fields = valid_fields[:]
    from openpyxl import Workbook
    import os

    # Mapeia header_id → metadados
    header_map = dict(excel_data)
    wb = Workbook()
    wb.remove(wb.active)  # remove aba padrão

    for gene, entries in sorted(gene_dict.items()):
        ws = wb.create_sheet(title=gene[:31])  # Excel limita nome da aba a 31 caracteres
        ws.append(["GenBank_ID"] + header_fields)
        
        entries = sorted(entries, key=lambda x: header_map.get(x[2], {}).get("organism", "").lower())
         
        for head, _, original_id in entries:
            meta = header_map.get(original_id, {})
            ws.append([original_id] + [meta.get(f, "") for f in header_fields])

    out_path = os.path.join(os.path.dirname(output_base), os.path.basename(output_base) + "_genes_metadados.xlsx")
    wb.save(out_path)

def gerar_excel_matriz_gene_vs_amostra(gene_dict, excel_data, header_fields, output_base):
    from openpyxl import Workbook
    import os

    header_map = dict(excel_data)
    genes = sorted(gene_dict.keys())
    amostras = {}

    # Coleta metadados por ID
    meta_por_id = {
        genbank_id: {field: valores.get(field, '') for field in header_fields}
        for genbank_id, valores in header_map.items()
    }

    # Preenche matriz com GenBank ID como chave interna
    for gene, seqs in gene_dict.items():
        for _, _, genbank_id in seqs:
            if genbank_id in meta_por_id:
                if genbank_id not in amostras:
                    amostras[genbank_id] = {
                        "metadados": meta_por_id[genbank_id],
                        "genes": {g: '' for g in genes}
                    }
                amostras[genbank_id]["genes"][gene] = genbank_id

    # Cria planilha
    wb = Workbook()
    ws = wb.active
    ws.title = "matriz_gene_vs_amostra"
    ws.append(header_fields + genes)

    ordenado = sorted(
    amostras,
    key=lambda x: amostras[x]["metadados"].get("organism", "").lower()
    )
    
    for genbank_id in ordenado:
        meta = amostras[genbank_id]["metadados"]
        gene_map = amostras[genbank_id]["genes"]
        linha = [meta[f] for f in header_fields] + [gene_map[g] for g in genes]
        ws.append(linha)

    out_path = os.path.join(os.path.dirname(output_base), os.path.basename(output_base) + "_matriz_gene_amostra.xlsx")
    wb.save(out_path)
                      
def download_sequences(genbank_ids, output_base, header_fields, config, genes, query=None, parent=None):

    genbank_ids = genbank_ids or []
    include_id = config["include_id"]
    extract_all_genes = config["extract_all_genes"]
    remover_sobrepos = config["remover_sobrepos"]
    unique_species = config.get("unique_species", False)
    log_ausentes = config.get("log_ausentes", False)

    if not genbank_ids and not query:
        messagebox.showinfo("Aviso", "Nenhum ID encontrado.")
        return

    def create_loading_window_with_progress(parent):
        win = Toplevel(parent)
        win.title("Baixando")
        win.geometry("400x120")
        Label(win, text="🔄 Baixando dados do GenBank...\nAguarde alguns minutos.").pack(pady=10)
        progress_var = DoubleVar()
        progress = ttk.Progressbar(win, orient="horizontal", mode="determinate", maximum=100, length=300, variable=progress_var)
        progress.pack(pady=10)
        win.update()
        return win, progress_var, progress

    org_type = config.get("org_type", "animal_mito")
    if org_type == "animal_mito":
        alias_map = alias_map_animal
    elif org_type == "planta_mito":
        alias_map = alias_map_mito_planta
    elif org_type == "planta_cloro":
        alias_map = alias_map_cloroplasto
    else:
        alias_map = alias_map_animal

    genes_desejados = set()
    
    def normalize(text):
        return unicodedata.normalize("NFKC", text).strip().upper()
    
    if genes and genes.strip():
        for g in genes.split(","):
            g = g.strip()
            if not g:
                continue
            norm_g = normalize(g)
            match = None
            for main_name in alias_map:
                if normalize(main_name) == norm_g:
                    match = main_name
                    break
            genes_desejados.add(match if match else g)
        
    faltantes_por_record = defaultdict(list) if log_ausentes else {}
    
    motivos_remocao = defaultdict(list)  # Novo dicionário para rastrear motivos de remoção

    # Correção: extrair todos os genes se nenhum for especificado
    if extract_all_genes and not genes_desejados:
        genes_desejados = set(alias_map.keys())
        #print("⚠️ Nenhum gene especificado — extraindo todos os genes do alias_map")
    aliases_desconhecidos = set()
    aliases_duplicados = set()
    agrupador_leu = defaultdict(list)
    agrupador_ser = defaultdict(list)

    loading_win = None
    try:
        base_dir = Path.home() / "Documents" / "GenBank_Output"
        nome_base = os.path.basename(output_base)
        output_dir = base_dir / nome_base
        output_base = str(output_dir / nome_base)
        os.makedirs(output_dir, exist_ok=True)
        gene_folder = os.path.join(os.path.dirname(output_base), os.path.basename(output_base) + "_genes")

        fasta_file = output_base + "_sequencias.fasta"
        excel_file = output_base + "_metadados.xlsx"
        log_file = output_base + "_log.txt"

        if parent:
            loading_win, progress_var, progress_bar = create_loading_window_with_progress(parent)

        all_records = []
        batch_size = 500
        ignored_ids = []

        if query:
            search_handle = Entrez.esearch(db="nucleotide", term=query, usehistory="y", retmax=0)
            search_results = Entrez.read(search_handle)
            count = int(search_results["Count"])
            webenv = search_results["WebEnv"]
            query_key = search_results["QueryKey"]

            for start in range(0, count, batch_size):
                with Entrez.efetch(db="nucleotide", rettype="gb", retmode="text", retstart=start, retmax=batch_size, webenv=webenv, query_key=query_key) as handle:
                    for rec in SeqIO.parse(handle, "genbank"):
                        try:
                            seq_string = str(rec.seq).upper()
                            if not rec.seq or len(seq_string.strip("N")) == 0 or "SEQUENCE CONTENT IS UNDEFINED" in seq_string:
                                ignored_ids.append(rec.id)
                                continue
                            all_records.append(rec)
                        except Exception:
                            ignored_ids.append(rec.id)
                            continue
                if parent:
                    progresso = int(((start + batch_size) / count) * 100)
                    progress_var.set(min(progresso, 100))
                    progress_bar.update()
                    parent.update()
        else:
            for i in range(0, len(genbank_ids), batch_size):
                chunk = genbank_ids[i:i + batch_size]
                with Entrez.efetch(db="nucleotide", id=chunk, rettype="gb", retmode="text") as handle:
                    for rec in SeqIO.parse(handle, "genbank"):
                        try:
                            seq_string = str(rec.seq).upper()
                            if not rec.seq or len(seq_string.strip("N")) == 0 or "SEQUENCE CONTENT IS UNDEFINED" in seq_string:
                                ignored_ids.append(rec.id)
                                continue
                            all_records.append(rec)
                        except Exception:
                            ignored_ids.append(rec.id)
                            continue
                if parent:
                    progresso = int(((i + batch_size) / len(genbank_ids)) * 100)
                    progress_var.set(min(progresso, 100))
                    progress_bar.update()
                    parent.update()

        min_len = config.get("min_len", 0)
        max_len = config.get("max_len", 999999)
        all_records = [rec for rec in all_records if min_len <= len(rec.seq) <= max_len]

        filtered_records = []
        species_seen = set()
        excel_data = []
        fields_excel = valid_fields
        gene_dict = {}
        ignored_aliases = set()
        all_log_sobreposicoes = []
        seen_genes = set()
        seen_headers = set()
        seen_leu_ser = set()

        for record in all_records:
            record_id = record.id  # 🔹 define antes de qualquer uso
            organism = record.annotations.get("organism", "Unknown")
            
            if unique_species and organism in species_seen:
                motivos_remocao[record_id].append("Duplicata por espécie (unique_species ativado)")
                continue
            species_seen.add(organism)

            values = []
            feature_info = {f: "" for f in fields_excel}
            for field in header_fields:
                val = "Unknown"
                for feature in record.features:
                    if feature.type == "source":
                        val = feature.qualifiers.get(field, ["Unknown"])[0]
                        break
                values.append(val.replace(" ", "_"))

            for feature in record.features:
                if feature.type == "source":
                    for f in fields_excel:
                        if f in feature.qualifiers:
                            feature_info[f] = feature.qualifiers[f][0]
                    break

            genbank_id_clean = record.id.split(".")[0]
            record.annotations["original_id"] = genbank_id_clean

            header_id = "_".join(values)
            if include_id:
                header_id += f"_{genbank_id_clean}"
            
            original_header = header_id
            suffix = 1
            while header_id in seen_headers:
                header_id = f"{original_header}_{suffix}"
                suffix += 1
            seen_headers.add(header_id)
            
            record.id = header_id
            record.description = ""

            genes_encontrados = set()

            if extract_all_genes:
                extrair_genes_geral(
                    record,
                    header_id,
                    alias_map,
                    genes_desejados,
                    seen_genes,
                    gene_dict,
                    aliases_desconhecidos,
                    aliases_duplicados,
                    agrupador_leu,
                    agrupador_ser,
                    seen_leu_ser
                )
                    
                if remover_sobrepos and org_type == "animal_mito":
                    os.makedirs(gene_folder, exist_ok=True)
                    corrigir_sobreposicoes_em_animais(record, gene_dict, alias_map, gene_folder)

                for gene, seqs in gene_dict.items():
                    for head, seq, seq_original_id in seqs:
                        if seq_original_id == record.annotations["original_id"]:
                            genes_encontrados.add(gene)
                            break

            if not extract_all_genes or genes_encontrados:
                filtered_records.append(record)
                excel_data.append((record.annotations["original_id"], feature_info))
            else:
                motivos_remocao[record_id].append("Falha na extração de genes: nenhum gene extraído")
                continue

#        if extract_all_genes and not genes_desejados:
#            genes_desejados = set(gene_dict.keys())
            
        if extract_all_genes and not genes:
            genes_desejados = set(gene_dict.keys())

        if log_ausentes and genes_desejados:
            os.makedirs(gene_folder, exist_ok=True)
            log_path = os.path.join(gene_folder, "processamento.log")
            with open(log_path, "w") as logf:
                for record in filtered_records:
                    found_genes = set()
                    record_id = record.annotations.get("original_id", record.id)
                    for gene, seqs in gene_dict.items():
                        for _, _, seq_original_id in seqs:
                            if seq_original_id == record_id:
                                found_genes.add(gene)
                                break
                    ausentes = genes_desejados - found_genes
                    if ausentes:
                        nome = record.annotations.get("organism", "Unknown")
                        chave = f"{nome} ({record_id})"
                        logf.write(f"[{chave}]\n")
                        for gene in sorted(ausentes):
                            logf.write(f"⚠️ {gene} ausente\n")
                        logf.write("\n")
                logf.write(f"Processamento concluído para {len(filtered_records)} amostras.\n")

        if filtered_records:
            with open(fasta_file, "w") as f_out:
                SeqIO.write(filtered_records, f_out, "fasta")

        wb = Workbook()
        ws = wb.active
        ws.append(["GenBank_ID"] + fields_excel)
        excel_data.sort(key=lambda x: x[1].get("organism", "").lower())
        for rid, info in excel_data:
            ws.append([rid] + [info.get(f, "") for f in fields_excel])
        wb.save(excel_file)

        if extract_all_genes and gene_dict:
            os.makedirs(gene_folder, exist_ok=True)
            log_path = os.path.join(gene_folder, "log_genes.txt")
            with open(log_path, "w") as log:
                log.write("[RESUMO]\n")
                for gene in sorted(gene_dict):
                    entries = gene_dict[gene]
                    path = os.path.join(gene_folder, f"{gene}.fasta")
                    with open(path, "w") as out:
                        for head, seq, *_ in entries:
                            out.write(f">{head}\n{seq}\n")
                    log.write(f"{gene}: {len(entries)} sequências extraídas\n")
                    
                log.write("\n[AGRUPAMENTOS TRNA-LEU/SER POR PADRÃO POSICIONAL]\n")
                agrupamentos_combinados = list(agrupador_leu.items()) + list(agrupador_ser.items())
                for tag, entradas in sorted(agrupamentos_combinados):
                    log.write(f"{tag}: {len(entradas)} sequências agrupadas\n")

         # 🔽 Grava arquivos de tRNA-Leu e tRNA-Ser por padrão posicional
        for tag, entradas in agrupador_leu.items():
            path = os.path.join(gene_folder, f"{tag}.fasta")
            with open(path, "w") as out:
                for header, seq, oid in entradas:
                    out.write(f">{header}\n{seq}\n")
         
        for tag, entradas in agrupador_ser.items():
            path = os.path.join(gene_folder, f"{tag}.fasta")
            with open(path, "w") as out:
                for header, seq, oid in entradas:
                    out.write(f">{header}\n{seq}\n")


        if aliases_desconhecidos:
            with open(os.path.join(gene_folder, "aliases_desconhecidos.txt"), "w") as logf:
                for alias in sorted(aliases_desconhecidos):
                    logf.write(alias + "\n")

        if aliases_duplicados:
            with open(os.path.join(gene_folder, "aliases_duplicados.txt"), "w") as logf:
                for alias in sorted(aliases_duplicados):
                    logf.write(alias + "\n")

        with open(log_file, "w") as lf:
            lf.write(f"Arquivo FASTA gerado: {fasta_file}\n")
            lf.write(f"Arquivo Excel gerado: {excel_file}\n")
            lf.write(f"Total de sequências encontradas (antes dos filtros): {len(all_records)}\n")
            lf.write(f"Total de sequências salvas: {len(filtered_records)}\n")
            lf.write("\n")
            if motivos_remocao:
                lf.write(f"🔎 Sequências removidas pelos filtros aplicados: {len(all_records) - len(filtered_records)}\n")
                for rec_id, motivos in motivos_remocao.items():
                    motivos_str = "; ".join(motivos)
                    lf.write(f"{rec_id}: {motivos_str}\n")
            else:
                lf.write("✅ Nenhuma sequência foi removida pelos filtros.\n")
            lf.write("\n")
            if query:
                lf.write(f"Query de busca utilizada: {query}\n")
            lf.write(f"Campos usados no cabeçalho: {', '.join(header_fields)}\n")
            lf.write(f"Incluir GenBank ID no cabeçalho: {'Sim' if include_id else 'Não'}\n")
            if extract_all_genes:
                lf.write(f"Extração de genes separada ativada: {len(gene_dict)} genes agrupados por sinônimo\n")

        if parent and loading_win:
            loading_win.destroy()

        messagebox.showinfo("Sucesso", f"Download completo!\nArquivos salvos com base em:\n{output_base}")

        if extract_all_genes and len(gene_dict) > 1 and len(all_records) > 1:
            gerar_excel_metadados_por_gene(gene_dict, excel_data, header_fields, output_base)

        if query and " " in query and not (" OR " in query or "," in query):
            gerar_excel_matriz_gene_vs_amostra(gene_dict, excel_data, header_fields, output_base)

    except Exception as e:
        if loading_win:
            loading_win.destroy()
        traceback.print_exc()
        messagebox.showerror("Erro", f"Erro ao processar sequências: {e}")
               
def iniciar_busca():
    titulo = entry_titulo.get().strip()
    organismos = entry_org.get().strip()
    genes = entry_genes.get().strip()
    campos = entry_campos.get().strip()
    output_nome = entry_saida.get().strip()
    include_id = var_id.get()
    mito = var_mito.get()
    mitogenoma = var_mitogenoma.get()
    ids_text = entry_ids.get("1.0", tk.END).strip()
    cloroplasto = var_cloroplasto.get()
    min_len = entry_min_len.get().strip()
    max_len = entry_max_len.get().strip()
    excluir_unverified = var_excluir_unverified.get()
    
    add_unverified_exclusion = excluir_unverified

    if not campos or not output_nome:
        messagebox.showwarning("Campos obrigatórios", "Preencha os campos obrigatórios: saída e campos do cabeçalho.")
        return

    header_fields = [c.strip() for c in campos.split(",")]
    invalid_fields = [f for f in header_fields if f not in valid_fields]
    if invalid_fields:
        messagebox.showerror("Erro", f"Campos inválidos: {', '.join(invalid_fields)}")
        return

    if ids_text:
        ids = [i.strip() for i in re.split(r"[\s,]+", ids_text) if i.strip()]
        proceed = messagebox.askyesno(
            "Confirmação",
            f"🔢 {len(ids)} IDs fornecidos manualmente.\n\nDeseja iniciar o download?"
        )
        if proceed:
            output_dir = os.path.join(os.path.expanduser("~"), "Documents", "GenBank_Output")
            output_base = os.path.join(output_dir, output_nome)
            config = {
                "include_id": include_id,
                "extract_all_genes": var_extract_all_genes.get(),
                "remover_sobrepos": var_remover_sobrepos.get(),
                "unique_species": var_unique_species.get(),
                "min_len": int(entry_min_len.get() or 0),
                "max_len": int(entry_max_len.get() or 999999),
                "log_ausentes": var_log_ausentes.get(),
                "org_type": var_org_type.get()
            }
            threading.Thread(
                target=download_sequences,
                args=(ids, output_base, header_fields, config, "", None, root)
            ).start()
        return

    if not any([genes, organismos, titulo, mito, mitogenoma]):
        messagebox.showwarning("Busca inválida", "Informe genes, organismo, título ou selecione pelo menos uma opção de mitocôndria/mitogenoma para realizar a busca.")
        return

    # Define o mapa de sinônimos
    org_type = var_org_type.get()
    alias_map = {
        "animal_mito": alias_map_animal,
        "planta_mito": alias_map_mito_planta,
        "planta_cloro": alias_map_cloroplasto
    }.get(org_type, alias_map_animal)

    # Gera os sinônimos de gene
    gene_query = ""
    selected_genes = [g.strip() for g in genes.split(",") if g.strip()]
    grouped_aliases = []
    for g in selected_genes:
        match_found = False
        for main_name, aliases in alias_map.items():
            if g.upper() == main_name.upper():
                group = " OR ".join(f'"{a}"' if " " in a else a for a in aliases)
                grouped_aliases.append(f"({group})")
                match_found = True
                break
        if not match_found:
            grouped_aliases.append(f'"{g}"' if " " in g else g)
            
        if grouped_aliases:
            gene_query = " OR ".join(grouped_aliases)
        
    query_parts = []
    if gene_query:
        query_parts.append(f"({gene_query})")

    if organismos:
        org_query = " OR ".join([f'"{o.strip()}"[Organism]' for o in organismos.split(",")])
        query_parts.append(f"({org_query})")

    if mito:
        query_parts.append("mitochondrial")

    if mitogenoma:
        query_parts.append("mitochondrion[Filter]")

    if cloroplasto:
        query_parts.append("chloroplast[Filter]")

    if titulo:
        query_parts.append(titulo)
     
    if min_len or max_len:
        try:
            min_val = int(min_len) if min_len else ""
            max_val = int(max_len) if max_len else ""
            
            if min_val and max_val:
                query_parts.append(f"{min_val}:{max_val}[SLEN]")
            elif min_val:
                query_parts.append(f"{min_val}:99999999[SLEN]")
            elif max_val:
                query_parts.append(f"2:{max_val}[SLEN]")
        except ValueError:
            messagebox.showwarning("Aviso", "Os valores de tamanho mínimo/máximo devem ser números inteiros.")
            return

    query = " AND ".join(query_parts)
    query += " NOT wgs[prop] NOT tsa[prop]"
    
    if add_unverified_exclusion:
        query += " NOT UNVERIFIED"

    ids = search_genbank(query)
    if ids:
        proceed = messagebox.askyesno(
            "Registros encontrados",
            f"🔢 {len(ids)} registros encontrados.\n\nDeseja iniciar o download?"
        )
        if proceed:
            output_dir = os.path.join(os.path.expanduser("~"), "Documents", "GenBank_Output")
            output_base = os.path.join(output_dir, output_nome)
            config = {
                "include_id": include_id,
                "extract_all_genes": var_extract_all_genes.get(),
                "remover_sobrepos": var_remover_sobrepos.get(),
                "unique_species": var_unique_species.get(),
                "min_len": int(entry_min_len.get() or 0),
                "max_len": int(entry_max_len.get() or 999999),
                "log_ausentes": var_log_ausentes.get(),
                "org_type": org_type
            }
            threading.Thread(
                target=download_sequences,
                args=(ids, output_base, header_fields, config, genes, query, root)
            ).start()
    else:
        messagebox.showinfo("Sem resultados", "Nenhum ID encontrado para a busca.")
        
# Interface Gráfica
root = tk.Tk()
if os.name == "nt":
    root.iconbitmap("pynnotate.ico")
root.title("Pynnotate_v1")
root.geometry("720x820")

Label(root, text="1) Selecionar a biblioteca genômica", font=("Arial", 14, "bold")).pack(anchor="center", pady=(0, 3), padx=10)

#tk.Label(root, text="Tipo de Organismo/Organela:").pack()
frame_org = tk.Frame(root)
var_org_type = StringVar(value="animal_mito")
tk.Radiobutton(frame_org, text="Mitocôndria animal", variable=var_org_type, value="animal_mito").pack(side="left", padx=5)
tk.Radiobutton(frame_org, text="Mitocôndria vegetal", variable=var_org_type, value="planta_mito").pack(side="left", padx=5)
tk.Radiobutton(frame_org, text="Cloroplasto", variable=var_org_type, value="planta_cloro").pack(side="left", padx=5)
frame_org.pack(pady=2)

Label(root, text="2) Montar query de busca personalizada", font=("Arial", 14, "bold")).pack(anchor="center", pady=(4, 4), padx=10)

tk.Label(root, text="🔎 Termo da publicação (título, autores, ano) [opcional]:").pack()
entry_titulo = tk.Entry(root, width=100)
entry_titulo.pack()

tk.Label(root, text="🧬 Gene(s) [ex: 16S, COI] [opcional]:").pack()
frame_genes = tk.Frame(root)
entry_genes = tk.Entry(frame_genes, width=50)
entry_genes.pack(side="left")
btn_genes = tk.Button(frame_genes, text="Selecionar genes", command=lambda: show_gene_selector(entry_genes, var_org_type.get()))
btn_genes.pack(side="left", padx=5)
frame_genes.pack()

tk.Label(root, text="🧫 Organismo(s) [opcional]:").pack()
entry_org = tk.Entry(root, width=60)
entry_org.pack()

Label(root, text="Refine os termos de busca para:", font=(12)).pack(anchor="center", pady=(0, 0), padx=2)

# 🧬 Frame para agrupar os botões lado a lado
frame_checkboxes = tk.Frame(root)
frame_checkboxes.pack(pady=2)

# Checkbox 1
var_mito = BooleanVar(value=False)
chk_mito = tk.Checkbutton(frame_checkboxes, text="Gene mitocondrial", variable=var_mito)
chk_mito.pack(side="left", padx=5)

# Checkbox 2
var_mitogenoma = BooleanVar(value=False)
chk_mitogenoma = tk.Checkbutton(frame_checkboxes, text="Mitogenoma", variable=var_mitogenoma)
chk_mitogenoma.pack(side="left", padx=5)

# Checkbox 3
var_cloroplasto = BooleanVar(value=False)
chk_cloroplasto = tk.Checkbutton(frame_checkboxes, text="Cloroplasto", variable=var_cloroplasto)
chk_cloroplasto.pack(side="left", padx=5)

# Checkbox 4
var_excluir_unverified = BooleanVar(value=False)
chk_excluir_unverified = tk.Checkbutton(frame_checkboxes, text="Excluir não anotados", variable=var_excluir_unverified)
chk_excluir_unverified.pack(side="left", padx=5)

tk.Label(root, text="📋 GenBank IDs (um por linha ou separados por vírgula) [opcional]:").pack()
entry_ids = tk.Text(root, height=6, width=70)
entry_ids.pack()

Label(root, text="3) Opções de formatação e filtragem", font=("Arial", 14, "bold")).pack(anchor="center", pady=(4, 4), padx=10)

tk.Label(root, text="📋 Campos do cabeçalho (selecione):").pack()
campos_frame = tk.Frame(root)
entry_campos = tk.Entry(campos_frame, width=50)
entry_campos.insert(0, "organism")
entry_campos.pack(side="left")
btn_campos = tk.Button(campos_frame, text="Selecionar", command=lambda: show_field_selector(entry_campos))
btn_campos.pack(side="left", padx=5)
campos_frame.pack()

var_id = BooleanVar(value=True)
chk_id = tk.Checkbutton(root, text="Incluir GenBank ID no cabeçalho fasta", variable=var_id)
chk_id.pack()

var_unique_species = BooleanVar(value=False)
chk_unique_species = tk.Checkbutton(root, text="Incluir apenas 1 indivíduo por espécie", variable=var_unique_species)
chk_unique_species.pack()

tk.Label(root, text="🔢 Tamanho mínimo da sequência (bp) [opcional]:").pack()
entry_min_len = Entry(root, width=20)
entry_min_len.pack()

tk.Label(root, text="🔢 Tamanho máximo da sequência (bp) [opcional]:").pack()
entry_max_len = Entry(root, width=20)
entry_max_len.pack()

# 🔽 Frame para agrupar todas as opções de extração de genes
frame_extracao = tk.Frame(root)
frame_extracao.pack(pady=(5, 5), padx=5)

# Variáveis
var_extract_all_genes = BooleanVar(value=True)
var_remover_sobrepos = BooleanVar(value=False)
var_log_ausentes = BooleanVar(value=False)

# Checkbutton principal
chk_extract_all_genes = tk.Checkbutton(
    frame_extracao,
    text="4) Extrair todos os genes anotados separadamente [opcional]",
    variable=var_extract_all_genes,
    command=lambda: atualizar_extracao_opcoes(),
    font=("Arial", 14, "bold")
)
chk_extract_all_genes.pack(anchor="center", padx=5)

# Checkbuttons adicionais (inicialmente ocultos)
chk_remover_sobrepos = tk.Checkbutton(
    frame_extracao,
    text="Corrigir sobreposição entre genes extraídos",
    variable=var_remover_sobrepos
)
chk_log_ausentes = tk.Checkbutton(
    frame_extracao,
    text="Gerar log de genes ausentes por amostra (útil para mitogenomas)",
    variable=var_log_ausentes,
    wraplength=680,
    justify="left"
)

# Desativa correção de sobreposição para mitocôndria vegetal ou cloroplasto
def atualizar_estado_checkbox_sobreposicao(*args):
    tipo = var_org_type.get()
    if tipo in ("planta_mito", "planta_cloro"):
        chk_remover_sobrepos.config(state="disabled")
        var_remover_sobrepos.set(False)
    else:
        chk_remover_sobrepos.config(state="normal")

# Liga a função ao tipo de organela
var_org_type.trace_add("write", atualizar_estado_checkbox_sobreposicao)

# Função para mostrar/ocultar opções adicionais
def atualizar_extracao_opcoes():
    if var_extract_all_genes.get():
        chk_remover_sobrepos.pack(anchor="center", pady=0)
        chk_log_ausentes.pack(anchor="center", pady=0)
        atualizar_estado_checkbox_sobreposicao()  # Garante estado correto mesmo se já estiver visível
    else:
        chk_remover_sobrepos.pack_forget()
        chk_log_ausentes.pack_forget()

tk.Label(root, text="5) Definir nome base da pasta de saída (ex: 16S_Leptodactylus):",font=("Arial", 14, "bold")).pack()
entry_saida = tk.Entry(root, width=40)
entry_saida.pack()

btn = tk.Button(root, text="💾 Buscar e baixar sequências", command=iniciar_busca, bg="green", fg="black")
btn.pack(pady=10)

root.mainloop()